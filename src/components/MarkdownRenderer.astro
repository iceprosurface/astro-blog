---
import { unified } from "unified";
import remarkParse from "remark-parse";
import remarkRehype from "remark-rehype";
import rehypeStringify from "rehype-stringify";
import rehypeShiki from "@shikijs/rehype";
import remarkGfm from "remark-gfm";
import remarkFootnotes from "../plugins/remark-footnotes.mjs";
import remarkCallout from "../plugins/remark-callout.mjs";
import remarkMath from "remark-math";
import remarkMathFlag from "../plugins/remark-math-flag.mjs";
import remarkCjkFriendly from "remark-cjk-friendly";
import rehypeResolveInternalLinks from "../plugins/rehype-resolve-internal-links.mjs";
import rehypeMarkExternalLinks from "../plugins/rehype-mark-external-links.mjs";
import rehypeSlug from "../plugins/rehype-slug.mjs";
import rehypeKatex from "rehype-katex";
import { visit } from "unist-util-visit";
import { PathMapper } from "../utils/path-mapper/path-mapper.js";
import path from "path";

interface Props {
  content: string; // 原始 markdown 文本
  filePath: string; // 文件路径（相对于 content 目录，如 "blog/test.md"）
}

const { content, filePath } = Astro.props;

// 构建 file path（用于 rehype 插件）
const contentDir = "src/content/blog";
const fullPath = path.join(process.cwd(), contentDir, filePath);

// 确保 PathMapper 已构建
const mapper = await PathMapper.getInstance({ contentDir });

// 获取所有图片资源映射
const images = import.meta.glob(
  "/src/content/blog/**/*.{png,jpg,jpeg,gif,svg,webp}",
  {
    eager: true,
    query: "?url",
    import: "default",
  },
);

/**
 * Rehype 插件：解析相对路径图片
 */
function rehypeResolveRelativeAssets() {
  return (tree: any) => {
    visit(tree, "element", (node: any) => {
      if (node.tagName === "img" && node.properties && node.properties.src) {
        const src = node.properties.src as string;

        // 判断是否为相对路径：不以 / 开头，且不是绝对 URI (http, data, etc.)
        const isAbsolute = src.startsWith("/") || src.startsWith("\\");
        const isUri = /^[a-z]+:/i.test(src);

        if (!isAbsolute && !isUri) {
          try {
            // 解码 src (处理 URL 编码字符)
            const decodedSrc = decodeURI(src);

            // 计算图片的绝对路径
            const imageAbsPath = path.resolve(
              path.dirname(fullPath),
              decodedSrc,
            );

            // 计算相对于项目根目录的路径（用于匹配 glob key）
            let relPath = path.relative(process.cwd(), imageAbsPath);
            // 统一分隔符为 /
            relPath = relPath.split(path.sep).join("/");

            // 构造 key (确保以 / 开头)
            const key = "/" + relPath;

            // 查找资源
            const resolvedUrl = (images as Record<string, string>)[key];

            if (resolvedUrl) {
              node.properties.src = resolvedUrl;
            } else {
              // 尝试不解码的情况 (Fallback)
              const imageAbsPathRaw = path.resolve(path.dirname(fullPath), src);
              let relPathRaw = path.relative(process.cwd(), imageAbsPathRaw);
              relPathRaw = relPathRaw.split(path.sep).join("/");
              const keyRaw = "/" + relPathRaw;
              const resolvedUrlRaw = (images as Record<string, string>)[keyRaw];

              if (resolvedUrlRaw) {
                node.properties.src = resolvedUrlRaw;
              } else {
                console.warn(
                  `[MarkdownRenderer] Could not resolve image: ${src} in ${filePath}. Key searched: ${key}`,
                );
              }
            }
          } catch (e) {
            console.error(
              `[MarkdownRenderer] Error parsing image src: ${src}`,
              e,
            );
          }
        }
      }
    });
  };
}

/**
 * Rehype 插件：为表格添加响应式包裹层
 */
function rehypeWrapTable() {
  return (tree: any) => {
    visit(tree, "element", (node: any, index: any, parent: any) => {
      if (node.tagName === "table") {
        const wrapper = {
          type: "element",
          tagName: "div",
          properties: {
            className: ["table-wrapper"],
          },
          children: [node],
        };
        parent.children[index] = wrapper;
      }
    });
  };
}

// 创建处理器
const processor = unified()
  .use(remarkParse)
  .use(remarkGfm) // Support GFM features like tables
  .use(remarkFootnotes) // Support footnotes [^1]
  .use(remarkMath)
  .use(remarkMathFlag)
  .use(remarkCjkFriendly)
  .use(remarkCallout)
  .use(remarkRehype, { allowDangerousHtml: true })
  .use(rehypeResolveRelativeAssets) // 解析相对路径图片 - 需在其他 rehype 插件前执行，或尽早执行
  .use(rehypeWrapTable) // 为表格添加包裹层以支持移动端滚动
  .use(rehypeSlug) // Add stable IDs to headings
  .use(rehypeResolveInternalLinks, { contentDir })
  .use(rehypeMarkExternalLinks)
  .use(rehypeKatex, { output: "html" })
  .use(rehypeShiki, {
    themes: {
      light: "github-light",
      dark: "github-dark",
    },
    langs: [
      "javascript",
      "typescript",
      "python",
      "java",
      "rust",
      "go",
      "bash",
      "markdown",
      "html",
      "css",
      "json",
      "yaml",
      "xml",
      "sql",
      "php",
      "c",
      "cpp",
      "csharp",
      "ruby",
      "swift",
      "kotlin",
      "dart",
      "scala",
      "haskell",
      "lua",
      "perl",
      "r",
      "matlab",
      "nginx",
      "apache",
      "dockerfile",
      "vim",
      "shell",
      "powershell",
      "plaintext",
    ],
  } as any)
  .use(rehypeStringify, { allowDangerousHtml: true });

// 处理 markdown
const vfile = await processor.process({
  value: content,
  path: fullPath,
});

const htmlContent = String(vfile);
---

<article class="markdown-content" set:html={htmlContent} />

<script type="module">
  // 代码复制功能 - 在客户端动态添加按钮
  document.addEventListener("DOMContentLoaded", () => {
    // 查找所有 pre 元素
    const pres = document.querySelectorAll("pre");

    pres.forEach((pre) => {
      // 跳过已经有复制按钮的
      if (pre.closest(".code-block-wrapper")) {
        return;
      }

      // 检查是否为代码块
      const code = pre.querySelector("code");
      if (!code) return;

      // 创建包装器
      const wrapper = document.createElement("div");
      wrapper.className = "code-block-wrapper";
      pre.parentNode.insertBefore(wrapper, pre);
      wrapper.appendChild(pre);

      // 创建复制按钮
      const button = document.createElement("button");
      button.className = "shiki-copy-button";
      button.type = "button";
      button.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
          <path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"/>
          <path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"/>
        </svg>
      `;

      // 样式
      Object.assign(button.style, {
        position: "absolute",
        top: "0.5rem",
        right: "0.5rem",
        padding: "0.25rem 0.5rem",
        fontSize: "0.75rem",
        background: "rgba(0, 0, 0, 0.1)",
        border: "1px solid rgba(0, 0, 0, 0.2)",
        borderRadius: "0.25rem",
        cursor: "pointer",
        transition: "background-color 0.2s, opacity 0.2s",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: "10",
      });

      // 只有在支持 hover 的设备上才默认隐藏，hover 时显示
      if (window.matchMedia("(hover: hover)").matches) {
        button.style.opacity = "0";

        const show = () => (button.style.opacity = "1");
        const hide = () => (button.style.opacity = "0");

        wrapper.addEventListener("mouseenter", show);
        wrapper.addEventListener("mouseleave", hide);

        // 键盘访问支持
        button.addEventListener("focus", show);
        button.addEventListener("blur", hide);
      } else {
        button.style.opacity = "1";
      }

      // 深色模式适配
      const isDark =
        document.documentElement.classList.contains("dark") ||
        document.documentElement.getAttribute("data-theme") === "dark" ||
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (isDark) {
        button.style.background = "rgba(255, 255, 255, 0.1)";
        button.style.borderColor = "rgba(255, 255, 255, 0.2)";
      }

      // 悬停效果
      button.addEventListener("mouseenter", () => {
        button.style.background = isDark
          ? "rgba(255, 255, 255, 0.2)"
          : "rgba(0, 0, 0, 0.2)";
      });
      button.addEventListener("mouseleave", () => {
        button.style.background = isDark
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(0, 0, 0, 0.1)";
      });

      // 复制功能
      button.addEventListener("click", async () => {
        const text = code.innerText;

        try {
          await navigator.clipboard.writeText(text);

          // 显示复制成功状态
          button.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="#22c55e">
              <path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"/>
            </svg>
          `;

          setTimeout(() => {
            button.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"/>
                <path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"/>
              </svg>
            `;
          }, 2000);
        } catch (err) {
          console.error("Failed to copy code:", err);
        }
      });

      wrapper.appendChild(button);
    });
  });
</script>
